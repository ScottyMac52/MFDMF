name: .NET 8 Single EXE Publish

permissions:
  contents: write

on:
  push:
    branches: [ "main", "master" ]
    tags: [ "v*", "V*" ]
    paths-ignore:
      - ".github/workflows/**/*.yml"
      - ".github/workflows/**/*.yaml"
  pull_request:
    branches: [ "main", "master" ]
    paths-ignore:
      - ".github/workflows/**/*.yml"
      - ".github/workflows/**/*.yaml"
  workflow_dispatch:
    inputs:
      runtime_id:
        description: "RID (win-x64, linux-x64, osx-x64)"
        required: false
        default: "win-x64"
      configuration:
        description: "Build configuration"
        required: false
        default: "Release"
      self_contained:
        description: "Publish self-contained (true/false)"
        required: false
        default: "true"
      publish_trimmed:
        description: "Trim (true/false) — validate first"
        required: false
        default: "false"
      release_tag:
        description: "Release tag (e.g., v5.0.0). If blank, uses v<run_number>."
        required: false
        default: ""
      release_name:
        description: "Release name"
        required: false
        default: ""
      prerelease:
        description: "Override prerelease flag (true/false). Leave blank for auto."
        required: false
        default: ""

env:
  DOTNET_VERSION: "8.0.x"
  PROJECT_PATH: "MFDMF-App/MFDMFApp.csproj"   # ← CHANGE ME

  # Defaults that manual inputs can override
  RUNTIME_ID_DEFAULT: "win-x64"
  CONFIGURATION_DEFAULT: "Release"
  SELF_CONTAINED_DEFAULT: "true"
  PUBLISH_TRIMMED_DEFAULT: "false"

  # Publish settings
  PUBLISH_SINGLE_FILE: "true"
  READY_TO_RUN: "false"
  PUBLISH_DIR: "artifacts/publish"

  # Handy for scripts (avoid ${{ }} inside run blocks)
  REPO_OWNER: ${{ github.repository_owner }}
  REPO_NAME: ${{ github.event.repository.name }}

jobs:
  build-and-publish:
    runs-on: windows-2022

    outputs:
      runtime_id:      ${{ steps.resolve.outputs.runtime_id }}
      artifact_name:   ${{ steps.nameartifact.outputs.artifact_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - id: resolve
        name: Resolve effective settings
        shell: pwsh
        run: |
          $rid  = if ([string]::IsNullOrWhiteSpace("${{ github.event.inputs.runtime_id }}")) { "${{ env.RUNTIME_ID_DEFAULT }}" } else { "${{ github.event.inputs.runtime_id }}" }
          $conf = if ([string]::IsNullOrWhiteSpace("${{ github.event.inputs.configuration }}")) { "${{ env.CONFIGURATION_DEFAULT }}" } else { "${{ github.event.inputs.configuration }}" }
          $sc   = if ([string]::IsNullOrWhiteSpace("${{ github.event.inputs.self_contained }}")) { "${{ env.SELF_CONTAINED_DEFAULT }}" } else { "${{ github.event.inputs.self_contained }}" }
          $trim = if ([string]::IsNullOrWhiteSpace("${{ github.event.inputs.publish_trimmed }}")) { "${{ env.PUBLISH_TRIMMED_DEFAULT }}" } else { "${{ github.event.inputs.publish_trimmed }}" }

          "EFFECTIVE_RUNTIME_ID=$rid"       >> $env:GITHUB_ENV
          "EFFECTIVE_CONFIGURATION=$conf"   >> $env:GITHUB_ENV
          "EFFECTIVE_SELF_CONTAINED=$sc"    >> $env:GITHUB_ENV
          "EFFECTIVE_TRIMMED=$trim"         >> $env:GITHUB_ENV

          "runtime_id=$rid" >> $env:GITHUB_OUTPUT

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: ${{ runner.os }}-nuget-

      - name: Restore
        shell: pwsh
        run: dotnet restore

      - name: Build
        shell: pwsh
        run: dotnet build --no-restore -c "${{ env.EFFECTIVE_CONFIGURATION }}"

      - name: Test (if any)
        shell: pwsh
        run: |
          if (Get-ChildItem -Recurse -Filter *.csproj | Select-String -SimpleMatch "<IsTestProject>true</IsTestProject>" -Quiet) {
            dotnet test --no-build -c "${{ env.EFFECTIVE_CONFIGURATION }}" --logger "trx;LogFileName=test_results.trx"
          } else {
            Write-Host "No test projects detected."
          }

      - name: Publish single-file
        shell: pwsh
        run: |
          $rid  = "${{ env.EFFECTIVE_RUNTIME_ID }}"
          $conf = "${{ env.EFFECTIVE_CONFIGURATION }}"
          $sc   = "${{ env.EFFECTIVE_SELF_CONTAINED }}"
          $trim = "${{ env.EFFECTIVE_TRIMMED }}"
          $out  = "${{ env.PUBLISH_DIR }}/$rid"
          New-Item -ItemType Directory -Force -Path $out | Out-Null
          dotnet publish "${{ env.PROJECT_PATH }}" -c $conf -r $rid --self-contained:$sc `
            -p:PublishSingleFile=${{ env.PUBLISH_SINGLE_FILE }} `
            -p:PublishTrimmed=$trim `
            -p:IncludeNativeLibrariesForSelfExtract=true `
            -p:EnableCompressionInSingleFile=true `
            -p:ReadyToRun=${{ env.READY_TO_RUN }} `
            -o $out

      - id: nameartifact
        name: Name artifact
        shell: pwsh
        run: |
          "artifact_name=single-exe-${{ env.EFFECTIVE_RUNTIME_ID }}" >> $env:GITHUB_OUTPUT

      - name: Upload app artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.nameartifact.outputs.artifact_name }}
          path: ${{ env.PUBLISH_DIR }}/${{ env.EFFECTIVE_RUNTIME_ID }}
          if-no-files-found: error

  setup-exe:
    needs: build-and-publish
    if: needs.build-and-publish.outputs.runtime_id == 'win-x64'
    runs-on: windows-2022

    outputs:
      setup_artifact: ${{ steps.meta.outputs.setup_artifact }}

    steps:
      - name: Download app artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-and-publish.outputs.artifact_name }}
          path: _staging

      - name: Install Inno Setup
        shell: pwsh
        run: choco install innosetup -y

      - id: meta
        name: Detect EXE and set names
        shell: pwsh
        run: |
          $exe = Get-ChildItem -Path _staging -Recurse -Filter *.exe | Select-Object -First 1
          if (-not $exe) { throw "No .exe found under _staging" }
          $ExeName = $exe.Name
          $Tag = if ("${{ github.ref }}".StartsWith("refs/tags/")) { "${{ github.ref }}".Substring(10) } else { "${{ github.event.inputs.release_tag }}" }
          if ([string]::IsNullOrWhiteSpace($Tag)) { $Tag = "v${{ github.run_number }}" }
          "APP_NAME=${{ env.REPO_NAME }}"   >> $env:GITHUB_ENV
          "APP_VERSION=$Tag"                >> $env:GITHUB_ENV
          "APP_EXE_NAME=$ExeName"           >> $env:GITHUB_ENV
          "setup_artifact=setup-exe-win-x64" >> $env:GITHUB_OUTPUT

      - name: Generate installer script
        shell: pwsh
        run: |
          $lines = @()
          $lines += "[Setup]"
          $lines += "AppName=$env:APP_NAME"
          $lines += "AppVersion=$env:APP_VERSION"
          $lines += "AppPublisher=$env:REPO_OWNER"
          $lines += "DefaultDirName={pf}\$($env:APP_NAME)"
          $lines += "OutputDir=dist"
          $lines += "OutputBaseFilename=$($env:APP_NAME)-Setup-$($env:APP_VERSION)"
          $lines += "Compression=lzma"
          $lines += "SolidCompression=yes"
          $lines += ""
          $lines += "[Files]"
          $lines += "Source: ""_staging\*""; DestDir: ""{app}""; Flags: recursesubdirs createallsubdirs ignoreversion"
          $lines += ""
          $lines += "[Icons]"
          $lines += "Name: ""{group}\$($env:APP_NAME)""; Filename: ""{app}\$($env:APP_EXE_NAME)"""
          $lines += "Name: ""{commondesktop}\$($env:APP_NAME)""; Filename: ""{app}\$($env:APP_EXE_NAME)"""
          $lines += ""
          $lines += "[Run]"
          $lines += "Filename: ""{app}\$($env:APP_EXE_NAME)""; Description: ""Launch $($env:APP_NAME)""; Flags: nowait postinstall skipifsilent"
          $lines | Set-Content -Path installer.iss -Encoding UTF8

      - name: Build installer
        shell: pwsh
        run: |
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" "installer.iss"

      - name: Upload setup.exe artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.meta.outputs.setup_artifact }}
          path: dist/*.exe
          if-no-files-found: error

  release:
    if: github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/')
    needs:
      - build-and-publish
      - setup-exe
    runs-on: ubuntu-latest

    steps:
      - name: Compute release values
        id: relvals
        shell: bash
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
          else
            TAG="${{ github.event.inputs.release_tag }}"
            if [[ -z "$TAG" ]]; then TAG="v${GITHUB_RUN_NUMBER}"; fi
          fi
          NAME="${{ github.event.inputs.release_name }}"
          if [[ -z "$NAME" ]]; then NAME="Release ${TAG}"; fi
          PRE="${{ github.event.inputs.prerelease }}"
          if [[ -z "$PRE" ]]; then
            if [[ "$TAG" =~ -(alpha|beta|rc) ]]; then PRE="true"; else PRE="false"; fi
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "name=$NAME" >> "$GITHUB_OUTPUT"
          echo "prerelease=$PRE" >> "$GITHUB_OUTPUT"

      - name: Download app artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-and-publish.outputs.artifact_name }}
          path: _staging

      - name: Zip app files
        id: pack
        shell: bash
        run: |
          set -e
          TAG="${{ steps.relvals.outputs.tag }}"
          RID="${{ needs.build-and-publish.outputs.runtime_id }}"
          ARCHIVE="${REPO_NAME}-${TAG}-${RID}.zip"
          (cd _staging && zip -r "../$ARCHIVE" .)
          EXE_PATH="$(find _staging -maxdepth 3 -type f -name '*.exe' | head -n1 || true)"
          echo "archive=${ARCHIVE}" >> "$GITHUB_OUTPUT"
          echo "exe=${EXE_PATH}"     >> "$GITHUB_OUTPUT"

      - name: Download setup.exe artifact (if produced)
        if: needs.setup-exe.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.setup-exe.outputs.setup_artifact }}
          path: _setup

      - name: Create or update GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -e
          TAG="${{ steps.relvals.outputs.tag }}"
          NAME="${{ steps.relvals.outputs.name }}"
          PRE="${{ steps.relvals.outputs.prerelease }}"
          if gh release view "$TAG" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            echo "Release exists."
          else
            if [[ "$PRE" == "true" ]]; then
              gh release create "$TAG" --title "$NAME" --generate-notes --prerelease --latest --repo "$GITHUB_REPOSITORY" --target "$GITHUB_SHA"
            else
              gh release create "$TAG" --title "$NAME" --generate-notes --latest --repo "$GITHUB_REPOSITORY" --target "$GITHUB_SHA"
            fi
          fi

      - name: Upload release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -e
          TAG="${{ steps.relvals.outputs.tag }}"
          ARCHIVE="${{ steps.pack.outputs.archive }}"
          EXE="${{ steps.pack.outputs.exe }}"
          FILES=("$ARCHIVE")
          if [[ -n "$EXE" && -f "$EXE" ]]; then FILES+=("$EXE"); fi
          if compgen -G "_setup/*.exe" > /dev/null; then FILES+=(_setup/*.exe); fi
          gh release upload "$TAG" "${FILES[@]}" --clobber --repo "$GITHUB_REPOSITORY"
          echo "Release: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/releases/tag/${TAG}"
