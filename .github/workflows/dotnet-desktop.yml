name: .NET 8 Single EXE Publish

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master" ]
  workflow_dispatch:
    inputs:
      runtime_id:
        description: "RID (e.g., win-x64, linux-x64, osx-x64)"
        required: false
        default: "win-x64"
      configuration:
        description: "Build configuration"
        required: false
        default: "Release"
      self_contained:
        description: "Publish self-contained (true/false)"
        required: false
        default: "true"
      publish_trimmed:
        description: "Trim (true/false) — leave false unless you’ve validated"
        required: false
        default: "false"

env:
  DOTNET_VERSION: "8.0.x"
  CONFIGURATION: "Release"
  # Change this to your entry project that produces the EXE:
  PROJECT_PATH: "MFDMF-App/MFDMFApp.csproj"
  # Default runtime identifier (overridable via workflow_dispatch input):
  RUNTIME_ID: "win-x64"
  # Single-file & related publish settings:
  PUBLISH_SINGLE_FILE: "true"
  SELF_CONTAINED: "true"
  PUBLISH_TRIMMED: "false"
  READY_TO_RUN: "false"
  # Output folder (relative to repo root)
  PUBLISH_DIR: "artifacts/publish"
  # NuGet source override if needed (leave empty to use default sources)
  NUGET_SOURCE: ""

jobs:
  build-and-publish:
    runs-on: windows-2022  # Includes VS 2022 toolchain
    env:
      # Resolve inputs (strings) with fallbacks to env defaults
      EFFECTIVE_RUNTIME_ID: ${{ github.event.inputs.runtime_id || env.RUNTIME_ID }}
      EFFECTIVE_CONFIGURATION: ${{ github.event.inputs.configuration || env.CONFIGURATION }}
      EFFECTIVE_SELF_CONTAINED: ${{ github.event.inputs.self_contained || env.SELF_CONTAINED }}
      EFFECTIVE_TRIMMED: ${{ github.event.inputs.publish_trimmed || env.PUBLISH_TRIMMED }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Print settings
        run: |
          echo DOTNET_VERSION=${{ env.DOTNET_VERSION }}
          echo CONFIGURATION=${{ env.CONFIGURATION }}
          echo PROJECT_PATH=${{ env.PROJECT_PATH }}
          echo RUNTIME_ID=${{ env.RUNTIME_ID }}
          echo EFFECTIVE_RUNTIME_ID=${{ env.EFFECTIVE_RUNTIME_ID }}
          echo EFFECTIVE_CONFIGURATION=${{ env.EFFECTIVE_CONFIGURATION }}
          echo SELF_CONTAINED=${{ env.SELF_CONTAINED }}
          echo EFFECTIVE_SELF_CONTAINED=${{ env.EFFECTIVE_SELF_CONTAINED }}
          echo PUBLISH_TRIMMED=${{ env.PUBLISH_TRIMMED }}
          echo EFFECTIVE_TRIMMED=${{ env.EFFECTIVE_TRIMMED }}
          echo PUBLISH_DIR=${{ env.PUBLISH_DIR }}

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore
        run: |
          if [ -n "${{ env.NUGET_SOURCE }}" ]; then
            dotnet restore --source "${{ env.NUGET_SOURCE }}"
          else
            dotnet restore
          fi

      - name: Build (solution or repo)
        run: |
          # If you have a .sln, you can swap this to: dotnet build YourSolution.sln ...
          dotnet build --no-restore -c "${{ env.CONFIGURATION }}"

      - name: Run tests (if present)
        run: |
          if (Get-ChildItem -Recurse -Filter *.csproj | Select-String -SimpleMatch "<IsTestProject>true</IsTestProject>" -Quiet) {
            echo "Test projects detected. Running tests..."
            dotnet test --no-build -c "${{ env.CONFIGURATION }}" --logger "trx;LogFileName=test_results.trx"
          } else {
            echo "No test projects detected. Skipping tests."
          }

      - name: Publish single-file executable
        run: |
          $rid="${{ env.EFFECTIVE_RUNTIME_ID }}"
          $conf="${{ env.EFFECTIVE_CONFIGURATION }}"
          $selfContained="${{ env.EFFECTIVE_SELF_CONTAINED }}"
          $trimmed="${{ env.EFFECTIVE_TRIMMED }}"
          $out="${{ env.PUBLISH_DIR }}/$rid"

          # Ensure output directory exists
          New-Item -ItemType Directory -Force -Path "$out" | Out-Null

          # Publish with single-file options
          dotnet publish "${{ env.PROJECT_PATH }}" `
            -c "$conf" `
            -r "$rid" `
            --self-contained:$selfContained `
            -p:PublishSingleFile=${{ env.PUBLISH_SINGLE_FILE }} `
            -p:PublishTrimmed=$trimmed `
            -p:IncludeNativeLibrariesForSelfExtract=true `
            -p:EnableCompressionInSingleFile=true `
            -p:ReadyToRun=${{ env.READY_TO_RUN }} `
            -o "$out"

          Write-Host "Publish complete to $out"
        shell: pwsh

      - name: List published files
        run: |
          echo "Published files:"
          dir "${{ env.PUBLISH_DIR }}\${{ env.EFFECTIVE_RUNTIME_ID }}" -Recurse
        shell: pwsh

      - name: Upload artifact (single EXE + support files)
        uses: actions/upload-artifact@v4
        with:
          name: single-exe-${{ env.EFFECTIVE_RUNTIME_ID }}
          path: ${{ env.PUBLISH_DIR }}/${{ env.EFFECTIVE_RUNTIME_ID }}
          if-no-files-found: error
