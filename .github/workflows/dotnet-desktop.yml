name: .NET 8 Single EXE Publish

permissions:
  contents: write

on:
  push:
    branches: [ "main", "master" ]
    tags: [ "v*", "V*" ]
    paths-ignore:
      - ".github/workflows/**/*.yml"
      - ".github/workflows/**/*.yaml"
  pull_request:
    branches: [ "main", "master" ]
    paths-ignore:
      - ".github/workflows/**/*.yml"
      - ".github/workflows/**/*.yaml"
  workflow_dispatch:
    inputs:
      runtime_id:
        description: "RID (e.g., win-x64, linux-x64, osx-x64)"
        required: false
        default: "win-x64"
      configuration:
        description: "Build configuration"
        required: false
        default: "Release"
      self_contained:
        description: "Publish self-contained (true/false)"
        required: false
        default: "true"
      publish_trimmed:
        description: "PublishTrimmed (true/false)"
        required: false
        default: "false"
      release_tag:
        description: "Release tag (e.g., v5.0.0). Leave blank unless creating release."
        required: false
        default: ""

env:
  DOTNET_VERSION: 8.0.x
  PROJECT_PATH: MFDMF-App/MFDMFApp.csproj

  RUNTIME_ID_DEFAULT: win-x64
  CONFIGURATION_DEFAULT: Release
  SELF_CONTAINED_DEFAULT: true
  PUBLISH_TRIMMED_DEFAULT: false
  PUBLISH_SINGLE_FILE: true
  READY_TO_RUN: false

  PUBLISH_DIR: artifacts/publish
  NUGET_SOURCE: ""

jobs:
  build:
    name: Build & Publish
    runs-on: windows-latest

    outputs:
      artifact_name: ${{ steps.nameartifact.outputs.artifact_name }}
      publish_dir:   ${{ steps.nameartifact.outputs.publish_dir }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Compute effective inputs
        id: inputs
        shell: bash
        run: |
          echo "rid=${{ github.event.inputs.runtime_id || env.RUNTIME_ID_DEFAULT }}" >> $GITHUB_OUTPUT
          echo "conf=${{ github.event.inputs.configuration || env.CONFIGURATION_DEFAULT }}" >> $GITHUB_OUTPUT
          echo "sc=${{ github.event.inputs.self_contained || env.SELF_CONTAINED_DEFAULT }}" >> $GITHUB_OUTPUT
          echo "trim=${{ github.event.inputs.publish_trimmed || env.PUBLISH_TRIMMED_DEFAULT }}" >> $GITHUB_OUTPUT

      - name: Export effective inputs
        shell: bash
        run: |
          echo "EFFECTIVE_RUNTIME_ID=${{ steps.inputs.outputs.rid }}"        >> $GITHUB_ENV
          echo "EFFECTIVE_CONFIGURATION=${{ steps.inputs.outputs.conf }}"     >> $GITHUB_ENV
          echo "EFFECTIVE_SELF_CONTAINED=${{ steps.inputs.outputs.sc }}"      >> $GITHUB_ENV
          echo "EFFECTIVE_TRIMMED=${{ steps.inputs.outputs.trim }}"           >> $GITHUB_ENV

      - name: Restore
        shell: pwsh
        run: dotnet restore "${{ env.PROJECT_PATH }}"

      - name: Run tests (if present)
        shell: pwsh
        run: |
          if (Get-ChildItem -Recurse -Filter *.csproj | Select-String -List -SimpleMatch "<IsTestProject>true</IsTestProject>" -Quiet) {
            Write-Host "Test projects detected. Running tests..."
            dotnet test --no-build -c "${{ env.EFFECTIVE_CONFIGURATION }}" --logger "trx;LogFileName=test_results.trx"
          } else {
            Write-Host "No test projects detected. Skipping tests."
          }

      - name: Publish single-file executable
        shell: pwsh
        run: |
          $rid  = "${{ env.EFFECTIVE_RUNTIME_ID }}"
          $conf = "${{ env.EFFECTIVE_CONFIGURATION }}"
          $sc   = "${{ env.EFFECTIVE_SELF_CONTAINED }}"
          $trim = "${{ env.EFFECTIVE_TRIMMED }}"
          $out  = "${{ env.PUBLISH_DIR }}/$rid"

          New-Item -ItemType Directory -Force -Path "$out" | Out-Null

          dotnet publish "${{ env.PROJECT_PATH }}" `
            -c "$conf" `
            -r "$rid" `
            --self-contained:$sc `
            -p:PublishSingleFile=${{ env.PUBLISH_SINGLE_FILE }} `
            -p:PublishTrimmed=$trim `
            -p:IncludeNativeLibrariesForSelfExtract=true `
            -p:EnableCompressionInSingleFile=true `
            -p:ReadyToRun=${{ env.READY_TO_RUN }} `
            -o "$out"

          Write-Host "Publish complete to $out"

      - name: List published files
        shell: pwsh
        run: |
          Write-Host "Published files:"
          Get-ChildItem -Recurse "${{ env.PUBLISH_DIR }}\${{ env.EFFECTIVE_RUNTIME_ID }}"

      # ----------------- ADDED: build installer -----------------
      - name: Install Inno Setup
        if: runner.os == 'Windows'
        shell: pwsh
        run: choco install innosetup -y

      - name: Build installer (Inno Setup) from repo installer/installer.iss
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Resolve dotnet publish folder
          $pubRoot = Get-ChildItem -Directory -Path "${{ env.PUBLISH_DIR }}" | Select-Object -First 1
          if (-not $pubRoot) { throw "Publish output not found under ${{ env.PUBLISH_DIR }}" }
          $pub = $pubRoot.FullName

          # Compute version similar to release tag
          if ($env:GITHUB_REF -like 'refs/tags/*') {
            $tag = $env:GITHUB_REF -replace '^refs/tags/', ''
          } elseif ('${{ github.event.inputs.release_tag }}' -ne '') {
            $tag = '${{ github.event.inputs.release_tag }}'
          } else {
            $tag = 'v' + $env:GITHUB_RUN_NUMBER
          }

          # Ensure output dir exists
          New-Item -ItemType Directory -Force -Path "_setup" | Out-Null

          # Aux files location (must contain installer\installer.iss, appsettings.json, optional Modules\*.json)
          $aux = (Resolve-Path "installer").Path
          if (-not (Test-Path "$aux\installer.iss")) { throw "Missing installer\installer.iss" }

          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" `
            "/DPublishDir=$pub" `
            "/DSetupAux=$aux" `
            "/DAppVersion=$tag" `
            "/O_setup" `
            "installer\installer.iss"

          $built = Join-Path "_setup" ("MFDMF-Setup-" + $tag + ".exe")
          if (-not (Test-Path $built)) { throw "Installer not found: $built" }
      # ----------------- /ADDED -----------------

      - id: nameartifact
        name: Name artifact
        shell: pwsh
        run: |
          $artifactName = "single-exe-${{ env.EFFECTIVE_RUNTIME_ID }}"
          $publishDir   = "${{ env.PUBLISH_DIR }}\${{ env.EFFECTIVE_RUNTIME_ID }}"
          "artifact_name=$artifactName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "publish_dir=$publishDir"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.nameartifact.outputs.artifact_name }}
          path: |
            ${{ steps.nameartifact.outputs.publish_dir }}/**
            _setup/*.exe

  release:
    name: Release
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Determine release values
        id: relvals
        shell: bash
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
          else
            if [[ -n "${{ github.event.inputs.release_tag }}" ]]; then
              TAG="${{ github.event.inputs.release_tag }}"
            else
              TAG="v${GITHUB_RUN_NUMBER}"
            fi
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
            name: single-exe-${{ needs.build.outputs.artifact_name && env.RUNTIME_ID_DEFAULT || env.RUNTIME_ID_DEFAULT }}
            # fallback ensures we still fetch something if name isnâ€™t propagated

      - name: Create or update GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -e
          TAG="${{ steps.relvals.outputs.tag }}"
          NAME="${TAG#v}"
          PRERELEASE="false"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG exists."
          else
            echo "Creating release $TAG..."
            if [[ "$PRERELEASE" == "true" ]]; then
              gh release create "$TAG" --title "$NAME" --generate-notes --prerelease
            else
              gh release create "$TAG" --title "$NAME" --generate-notes
            fi
          fi

      - name: Zip publish folder for convenience
        id: pack
        shell: bash
        run: |
          set -e
          TAG="${{ steps.relvals.outputs.tag }}"
          RID="${{ env.RUNTIME_ID_DEFAULT }}"
          REPO_NAME="${GITHUB_REPOSITORY##*/}"
          ARCHIVE="${REPO_NAME}-${TAG}-${RID}.zip"
          if [ -d "single-exe-${RID}" ]; then
            zip -r "$ARCHIVE" "single-exe-${RID}"
          else
            echo "single-exe-${RID} not found; zipping current directory contents"
            zip -r "$ARCHIVE" .
          fi
          echo "archive=$ARCHIVE" >> "$GITHUB_OUTPUT"
          EXE_PATH="$(find . -maxdepth 3 -type f -name '*.exe' | head -n1 || true)"
          echo "exe=${EXE_PATH}" >> "$GITHUB_OUTPUT"

      - name: Upload release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -e
          TAG="${{ steps.relvals.outputs.tag }}"
          ARCHIVE="${{ steps.pack.outputs.archive }}"
          EXE="${{ steps.pack.outputs.exe }}"
          FILES=("$ARCHIVE")
          if [[ -n "$EXE" && -f "$EXE" ]]; then FILES+=("$EXE"); fi
          if compgen -G "_setup/*.exe" > /dev/null; then FILES+=(_setup/*.exe); fi
          gh release upload "$TAG" "${FILES[@]}" --clobber --repo "$GITHUB_REPOSITORY"
          echo "Release: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/releases/tag/${TAG}"
