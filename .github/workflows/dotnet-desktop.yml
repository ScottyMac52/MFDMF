name: .NET 8 Single EXE + Setup

permissions:
  contents: write

on:
  push:
    branches: [ "main", "master" ]
    tags: [ "v*", "V*" ]
    paths-ignore:
      - ".github/workflows/**/*.yml"
      - ".github/workflows/**/*.yaml"
  pull_request:
    branches: [ "main", "master" ]
    paths-ignore:
      - ".github/workflows/**/*.yml"
      - ".github/workflows/**/*.yaml"
  workflow_dispatch:
    inputs:
      runtime_id:
        description: "RID (e.g., win-x64, linux-x64, osx-x64)"
        required: false
        default: "win-x64"
      configuration:
        description: "Build configuration"
        required: false
        default: "Release"
      self_contained:
        description: "Publish self-contained (true/false)"
        required: false
        default: "true"
      publish_trimmed:
        description: "PublishTrimmed (true/false)"
        required: false
        default: "false"
      release_tag:
        description: "Release tag (e.g., v5.0.0). Leave blank unless creating release."
        required: false
        default: ""

env:
  DOTNET_VERSION: 8.0.x
  PROJECT_PATH: MFDMF-App/MFDMFApp.csproj

  RUNTIME_ID_DEFAULT: win-x64
  CONFIGURATION_DEFAULT: Release
  SELF_CONTAINED_DEFAULT: true
  PUBLISH_TRIMMED_DEFAULT: false
  PUBLISH_SINGLE_FILE: true
  READY_TO_RUN: false

  PUBLISH_DIR: artifacts/publish
  NUGET_SOURCE: ""

jobs:
  build:
    name: Build & Create Setup.exe
    runs-on: windows-latest

    outputs:
      tag: ${{ steps.itag.outputs.tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Compute effective inputs
        id: inputs
        shell: bash
        run: |
          echo "rid=${{ github.event.inputs.runtime_id || env.RUNTIME_ID_DEFAULT }}" >> $GITHUB_OUTPUT
          echo "conf=${{ github.event.inputs.configuration || env.CONFIGURATION_DEFAULT }}" >> $GITHUB_OUTPUT
          echo "sc=${{ github.event.inputs.self_contained || env.SELF_CONTAINED_DEFAULT }}" >> $GITHUB_OUTPUT
          echo "trim=${{ github.event.inputs.publish_trimmed || env.PUBLISH_TRIMMED_DEFAULT }}" >> $GITHUB_OUTPUT

      - name: Export effective inputs
        shell: bash
        run: |
          echo "EFFECTIVE_RUNTIME_ID=${{ steps.inputs.outputs.rid }}"        >> $GITHUB_ENV
          echo "EFFECTIVE_CONFIGURATION=${{ steps.inputs.outputs.conf }}"     >> $GITHUB_ENV
          echo "EFFECTIVE_SELF_CONTAINED=${{ steps.inputs.outputs.sc }}"      >> $GITHUB_ENV
          echo "EFFECTIVE_TRIMMED=${{ steps.inputs.outputs.trim }}"           >> $GITHUB_ENV

      - name: Restore
        shell: pwsh
        run: dotnet restore "${{ env.PROJECT_PATH }}"

      - name: Publish single-file executable
        shell: pwsh
        run: |
          $rid  = "${{ env.EFFECTIVE_RUNTIME_ID }}"
          $conf = "${{ env.EFFECTIVE_CONFIGURATION }}"
          $sc   = "${{ env.EFFECTIVE_SELF_CONTAINED }}"
          $trim = "${{ env.EFFECTIVE_TRIMMED }}"
          $out  = "${{ env.PUBLISH_DIR }}\$rid"
          New-Item -ItemType Directory -Force -Path "$out" | Out-Null

          dotnet publish "${{ env.PROJECT_PATH }}" `
            -c "$conf" `
            -r "$rid" `
            --self-contained:$sc `
            -p:PublishSingleFile=${{ env.PUBLISH_SINGLE_FILE }} `
            -p:PublishTrimmed=$trim `
            -p:IncludeNativeLibrariesForSelfExtract=true `
            -p:EnableCompressionInSingleFile=true `
            -p:ReadyToRun=${{ env.READY_TO_RUN }} `
            -o "$out"

      - name: Compute tag for naming
        id: itag
        shell: pwsh
        run: |
          if ($env:GITHUB_REF -like 'refs/tags/*') {
            $tag = $env:GITHUB_REF -replace '^refs/tags/', ''
          } elseif ('${{ github.event.inputs.release_tag }}' -ne '') {
            $tag = '${{ github.event.inputs.release_tag }}'
          } else {
            $tag = "v$($env:GITHUB_RUN_NUMBER)"
          }
          "tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Install Inno Setup
        shell: pwsh
        run: choco install innosetup -y

      - name: Ensure installer inputs (appsettings.json, Modules)
        shell: pwsh
        run: |
          $aux = Join-Path $PWD "installer"
          if (-not (Test-Path $aux)) { throw "Missing installer/ directory in repo" }

          $auxJson = Join-Path $aux "appsettings.json"
          if (-not (Test-Path $auxJson)) {
            if (Test-Path "appsettings.json") {
              Copy-Item "appsettings.json" $auxJson -Force
              Write-Host "Copied repo root appsettings.json -> installer/appsettings.json"
            } else {
              $data = [ordered]@{
                FileSpec = "*.json"
                FilePath = "C:\Program Files\Vyper Industries\MFDMF\Modules"
              } | ConvertTo-Json -Depth 2
              Set-Content -Path $auxJson -Value $data -Encoding UTF8
              Write-Host "Created default installer/appsettings.json"
            }
          }

          if (Test-Path "Modules") {
            $dst = Join-Path $aux "Modules"
            New-Item -ItemType Directory -Force -Path $dst | Out-Null
            Copy-Item "Modules\*.json" $dst -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "Copied Modules/*.json into installer/Modules"
          } else {
            Write-Host "No repo Modules folder; continuing"
          }

      - name: Build installer (Setup.exe)
        shell: pwsh
        run: |
          $pubRoot = Get-ChildItem -Directory -Path "${{ env.PUBLISH_DIR }}" | Select-Object -First 1
          if (-not $pubRoot) { throw "Publish output not found under ${{ env.PUBLISH_DIR }}" }
          $pub = $pubRoot.FullName
          $aux = (Resolve-Path "installer").Path
          $tag = "${{ steps.itag.outputs.tag }}"

          if (-not (Test-Path "$aux\installer.iss")) { throw "Missing installer\installer.iss" }

          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" `
            "/DPublishDir=$pub" `
            "/DSetupAux=$aux" `
            "/DAppVersion=$tag" `
            "/O_setup" `
            "installer\installer.iss"

          $built = Join-Path "_setup" ("MFDMF-Setup-" + $tag + ".exe")
          if (-not (Test-Path $built)) { throw "Installer not found: $built" }

      - name: Upload Setup.exe artifact
        uses: actions/upload-artifact@v4
        with:
          name: installer
          path: _setup/MFDMF-Setup-${{ steps.itag.outputs.tag }}.exe
          if-no-files-found: error

  release:
    name: Release
    needs: build
    runs-on: windows-latest   # keep windows so gh + path handling is consistent
    if: github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Determine release tag
        id: rel
        shell: pwsh
        run: |
          if ($env:GITHUB_REF -like 'refs/tags/*') {
            $tag = $env:GITHUB_REF -replace '^refs/tags/', ''
          } elseif ('${{ github.event.inputs.release_tag }}' -ne '') {
            $tag = '${{ github.event.inputs.release_tag }}'
          } else {
            $tag = "${{ needs.build.outputs.tag }}"
          }
          "tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Download Setup.exe artifact
        uses: actions/download-artifact@v4
        with:
          name: installer
          path: .

      - name: Create or update GitHub Release (attach Setup.exe)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          $repo = "$env:GITHUB_REPOSITORY"
          $tag  = '${{ steps.rel.outputs.tag }}'
          $name = $tag.TrimStart('v','V')

          # Ensure the release exists (avoid needing a .git folder)
          gh release view "$tag" --repo "$repo" *> $null
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Creating release $tag..."
            gh release create "$tag" --repo "$repo" --title "$name" --generate-notes
            if ($LASTEXITCODE -ne 0) { throw "Failed to create release $tag" }
          } else {
            Write-Host "Release $tag exists."
          }

          # Find the Setup.exe we downloaded from artifacts
          $setup = Get-ChildItem -Filter "MFDMF-Setup-*.exe" | Select-Object -First 1
          if (-not $setup) { throw "Setup.exe not found in workspace." }

          # Upload (overwrite if already present)
          gh release upload "$tag" "$($setup.FullName)" --repo "$repo" --clobber
          if ($LASTEXITCODE -ne 0) { throw "Failed to upload $($setup.Name) to release $tag" }

          Write-Host "Release ready: $env:GITHUB_SERVER_URL/$repo/releases/tag/$tag"
          $global:LASTEXITCODE = 0
